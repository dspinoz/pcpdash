<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>PCPDash</title>
    <script src='/jquery.js' type='text/javascript'></script>
    <script src='/bootstrap.js' type='text/javascript'></script>
    <link href='/bootstrap.css' rel='stylesheet' type='text/css'>
    
    <script src="/d3.js"></script>
    <script src="/queue.js"></script>
  </head>

  <body>
    
    <!-- Static navbar -->
    <div class="navbar navbar-default navbar-static-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">PCPDash</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="/index.html">Getting Started</a></li>
            <li class="active"><a href="/fetch.html">Fetch</a></li>
            <li><a href="/load.html">System Load</a></li>
          </ul>
        </div>
      </div>
    </div>
    
    
    <div class='container' style='font: 12px sans-serif;'>
      <div class='row'>
        <div class='span12'>
          
          <div class='container' id='content'></div>
          
          <button type="button" class="btn btn-default btn-lg" onclick="updateData()">
            <span class="glyphicon glyphicon-refresh"></span> Update
          </button>

        </div>
      </div>
    </div>
    
    <script type="text/javascript">
      
      function getMetricInstanceInfo(archive, callback) {
        
        if (!archive.metric.info)
        {
          console.log("ERROR: No metric info for " + archive.metric.name);
          callback(archive);
          return;
        }
        
        d3.json("/pmapi/"+archive.context+"/_indom?indom=" + archive.metric.info.indom, function(err, json) {
          
          if(err) {
            console.log("ERROR: Invalid indom for metric instance info");
            callback(null,archive);
            return;
          }
          
          if (json && json.instances) {
            archive.metric.instances = json.instances;
          }
          callback(null,archive);
        });
      }
      
      function getMetricInfo(archive, callback) {
        d3.json("/pmapi/"+archive.context+"/_metric?prefix=" + archive.metric.name, function(json) {
          
          var notMatched = [];
          
          json.metrics.forEach(function(m) {
            if (m.name === archive.metric.name)
            {
              console.log("MMMM", m);
              archive.metric.info = m;
            }
            else
            {
              notMatched.push(m);
            }
          });
          
          archive.metric.extras = notMatched;
          
          var q = queue();
          q.defer(getMetricInstanceInfo, archive);
          q.await(function(err, instInfo) {
            callback(null,instInfo);
          });
        });
      }
      
      function getMetricValue(archive, callback) {
        d3.json("/pmapi/"+archive.context+"/_fetch?names=" + archive.metric.name, function(err, json) {
          
          if (err) {
            console.log("ERROR: Invalid metric name");
            callback(null, archive);
            return;
          }
          
          if (json) {
            archive.metric.timestamp = json.timestamp;
            archive.metric.values = json.values;
          }
          
          callback(null,archive);
        });
      }
      
      function getMetrics(info, callback) {
        
        var q = queue();
        
        info.archives.forEach(function (a) {
          
          // TODO support multiple metrics
          a.metric = {name: info.metric};
          
          // multiple queries on the queue will generate multiple results
          // see awaitAll
          q.defer(getMetricInfo, a); //TODO client optimisation, info may not required
          q.defer(getMetricValue, a);
          
        });
        
        q.awaitAll(function(err, metrics) {
          console.log('all metric info', metrics);
          
          // cleanup the results, as multiple objects per archive will be present
          var metricsClean = [];
          var unique = {};
          
          metrics = metrics.filter(function(m) {
            if (!m || !m.file)
            {
              return false;
            }
            
            // use file to uniqely identify the archive
            // they have the same attributes/values
            if (unique[m.file] == undefined) {
              unique[m.file] = 1;
              return true;
            }
            return false;
          });
          
          callback(null,metrics);
        });
      }
      
      function getContext(archive, callback) {
        d3.json("/pmapi/context?archivefile=" + archive.file, function(json) {
          
          archive.context = json.context;
          
          callback(null,archive);
        });
      }
      
      function getContexts(archives, callback) {
        
        var q = queue();
        
        archives.forEach(function (a) {
          
          q.defer(getContext, a);
          
        });
        
        q.awaitAll(function(err, all) {
          console.log('contexts', all);
          callback(null,all);
        });
      }
      
      function getArchives(hosts, callback) {
        
        d3.json("/pcpdash/archives", function(json) {
          
          var archives = [];
          
          hosts.forEach(function(h) {
            var a = json.archives[h];
            
            if (!a) {
              return;
            }
            
            // value from newest archive
            archives.push({host: h, file: a[0].name});
          });
          
          callback(null,archives);
        });
      }
      
      function getHosts(info, callback) {
        
        d3.json("/pcpdash/hosts", function(json) {
          
          var hosts = [];
          var regex = new RegExp(info.host);
          
          json.hosts.forEach(function(h) {
            var match = regex.exec(h);
            if (match) {
              hosts.push(match[0]);
            }
          });
          
          callback(null,hosts);
        });
      }
      
      function updateData() {
        
        var q = queue();
        
        var ctx = {
          host: ".*", //TODO get from input field
          metric: "kernel.all.load" //TODO get from input field
        };
        
        q.defer(getHosts, ctx);
        
        q.await(function(err, hosts) {
          
          console.log('hosts', hosts);
          
          q = queue();
          
          q.defer(getArchives, hosts);
          
          q.await(function (err, archives) {
            
            if (err) {
              d3.select('#content').html(err);
              return;
            }
              
            d3.select('#content').html('<pre>GOT ARCHIVES: '+JSON.stringify(archives, false, ' ')+'</pre>');

            q = queue();
            
            q.defer(getContexts, archives);
            
            q.await(function(err, contexts) {
              d3.select('#content').html('<pre>GOT CONTEXTS: '+JSON.stringify(contexts, false, ' ')+'</pre>');
              
              q = queue();
              
              q.defer(getMetrics, {metric: ctx.metric, archives: archives});
              
              q.await(function(err, metrics) {
                console.log('metrics', metrics);
                d3.select('#content').html('<pre>GOT METRIC: '+JSON.stringify(metrics, false, ' ')+'</pre>');
              });
              
            });
            
          });
          
        });
        
      }
      
      updateData();
    
    </script>
    
  </body>
</html>
